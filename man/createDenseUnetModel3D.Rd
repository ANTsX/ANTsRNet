% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/createDenseUnetModel.R
\name{createDenseUnetModel3D}
\alias{createDenseUnetModel3D}
\title{3-D implementation of the dense U-net deep learning architecture.}
\usage{
createDenseUnetModel3D(inputImageSize, numberOfOutputs = 1,
  numberOfLayersPerDenseBlock = c(3, 4, 12, 8), growthRate = 48,
  initialNumberOfFilters = 96, reductionRate = 0, depth = 7,
  dropoutRate = 0, weightDecay = 1e-04, mode = "classification")
}
\arguments{
\item{inputImageSize}{Used for specifying the input tensor shape.  The
shape (or dimension) of that tensor is the image dimensions followed by
the number of channels (e.g., red, green, and blue).}

\item{numberOfOutputs}{Meaning depends on the \code{mode}.  For
'classification' this is the number of segmentation labels.  For 'regression'
this is the number of outputs.}

\item{growthRate}{number of filters to add for each dense block layer
(default = 48).}

\item{initialNumberOfFilters}{number of filters at the beginning
(default = 96).}

\item{reductionRate}{reduction factor of transition blocks}

\item{depth}{number of layers---must be equal to 3 * N + 4 where
N is an integer (default = 7).}

\item{dropoutRate}{drop out layer rate (default = 0.2).}

\item{weightDecay}{weight decay (default = 1e-4).}

\item{numberOfLayersPerDenseBlocks}{number of dense blocks per layer.}
}
\value{
an DenseUnet keras model
}
\description{
Creates a keras model of the dense U-net deep learning architecture for
image segmentation
}
\details{
X. Li, H. Chen, X. Qi, Q. Dou, C.-W. Fu, P.-A. Heng. H-DenseUNet: Hybrid
Densely Connected UNet for Liver and Tumor Segmentation from CT Volumes

available here:

https://arxiv.org/pdf/1709.07330.pdf

with the author's implementation available at:

https://github.com/xmengli999/H-DenseUNet
}
\examples{

library( ANTsRNet )
library( keras )

model <- createDenseUnetModel3D( c( 64, 64, 64, 1 ) )

metric_multilabel_dice_coefficient <-
  custom_metric( "multilabel_dice_coefficient",
    multilabel_dice_coefficient )

loss_dice <- function( y_true, y_pred ) {
  -multilabel_dice_coefficient(y_true, y_pred)
}
attr(loss_dice, "py_function_name") <- "multilabel_dice_coefficient"

model \%>\% compile( loss = loss_dice,
  optimizer = optimizer_adam( lr = 0.0001 ),
  metrics = c( metric_multilabel_dice_coefficient,
    metric_categorical_crossentropy ) )

print( model )

}
\author{
Tustison NJ
}
